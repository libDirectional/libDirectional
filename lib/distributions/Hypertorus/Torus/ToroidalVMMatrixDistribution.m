classdef ToroidalVMMatrixDistribution < AbstractToroidalDistribution
    % Bivariate von Mises, matrix version
    %
    % see http://en.wikipedia.org/wiki/Bivariate_von_Mises_distribution
    %
    % Mardia, K. V. 
    % Statistics of Directional Data 
    % Journal of the Royal Statistical Society. Series B (Methodological), 
    % Wiley for the Royal Statistical Society, 1975, 37, 349-393
    %
    % Mardia, K. V. & Jupp, P. E. Directional Statistics Wiley, 1999, 
    % Sec. 3.7.1
    %
    % Gerhard Kurz, Uwe D. Hanebeck,
    % Toroidal Information Fusion Based on the Bivariate von Mises Distribution
    % Proceedings of the 2015 IEEE International Conference on Multisensor Fusion and Information Integration (MFI 2015), 
    % San Diego, California, USA, September 2015.
    
    properties
        mu      % 2 x 1 location parameter 
        kappa   % 2 x 1 concentration paramter
        A       % 2 x 2 correlation parameter
        C       % normalization constant
    end
    
    methods
        function this = ToroidalVMMatrixDistribution(mu_, kappa_, A_)
            % Constructor
            %
            % Parameters:
            %   mu_ (2 x 1)
            %       location parameter
            %   kappa_ (2 x 1)
            %       concentration parameter (>=0)
            %   A_ (scalar)
            %       correlation parameter
            assert(size(mu_,1)==2);
            assert(size(mu_,2)==1);
            assert(size(kappa_,1)==2);
            assert(size(kappa_,2)==1);
            assert(size(A_,1)==2);
            assert(size(A_,2)==2);
            assert(kappa_(1) > 0);
            assert(kappa_(2) > 0);
            this.mu = mod(mu_,2*pi);
            this.kappa = kappa_;
            this.A = A_;
            
            % use approximation only in cases of low concentration to
            % ensure accurate normalization
            if this.kappa(2) > 1.5 || this.kappa(2)>1.5 || max(abs(this.A),[],[1,2]) > 1
                this.C = 1;
                this.C = 1/this.integral();
            else
                this.C = this.normConstApprox();
            end
        end
        
        function p = pdf(this, xa)
            % Evaluate pdf at each column of xa
            %
            % Parameters:
            %   xa (2 x n)
            %       n locations where to evaluate the pdf
            % Returns:
            %   p (1 x n)
            %       value of the pdf at each location
            
            assert(size(xa,1) == 2);

            exponent = this.kappa(1) * cos(xa(1,:) - this.mu(1)) ...
              + this.kappa(2) * cos(xa(2,:) - this.mu(2)) ...
              + cos(xa(1,:) - this. mu(1)) .* this.A(1,1) .* cos(xa(2,:) - this. mu(2)) ...
              + cos(xa(1,:) - this. mu(1)) .* this.A(1,2) .* sin(xa(2,:) - this. mu(2)) ...
              + sin(xa(1,:) - this. mu(1)) .* this.A(2,1) .* cos(xa(2,:) - this. mu(2)) ...
              + sin(xa(1,:) - this. mu(1)) .* this.A(2,2) .* sin(xa(2,:) - this. mu(2));
            p = this.C * exp ( exponent );
        end
        
        function C = normConstApprox(this, n)
            % Approximates the normalization constant using n summands.
            % Currently we support up to 8 summands.
            %
            % Parameters:
            %   n (scalar, integer > 0)
            %       number of summands to consider
            % Returns:
            %   C (scalar)
            %       normalization constant       
            %
            % Gerhard Kurz, Uwe D. Hanebeck,
            % Toroidal Information Fusion Based on the Bivariate von Mises Distribution
            % Proceedings of the 2015 IEEE International Conference on Multisensor Fusion and Information Integration (MFI 2015), 
            % San Diego, California, USA, September 2015.
            if nargin<2 
                n=8;
            end
            
            a11 = this.A(1,1); a12 = this.A(1,2); a21 = this.A(2,1); a22 = this.A(2,2);
            k1 = this.kappa(1); k2 = this.kappa(2);
            total = 0;
            total = total + 4*pi^2; % n=0
            if n>=1 
                total = total + 0/factorial(1); % n=1
            end
            if n>=2
                total = total + (a11^2+a12^2+a21^2+a22^2+2*k1^2+2*k2^2)*pi^2/factorial(2); % n=2
            end
            if n>=3
                total = total + (6*a11*k1*k2 *pi^2)/factorial(3); % n=3
            end
            if n>=4
                total = total + (3/16*(3*a11^4+3*a12^4+3*a21^4+8*a11*a12*a21*a22+6*a21^2*a22^2+3*a22^4+8*a21^2*k1^2+8*a22^2*k1^2+8*k1^4+8*(3*a21^2+a22^2+4*k1^2)*k2^2+8*k2^4+2*a11^2*(3*a12^2+3*a21^2+a22^2+12*(k1^2+k2^2))+2*a12^2*(a21^2+3*a22^2+4*(3*k1^2+k2^2)))*pi^2)/factorial(4); % n=4
            end
            if n>=5
                total = total + 0.15e2 / 0.4e1 * pi ^ 2 * k1 * k2 * (3 * a11 ^ 3 + 3 * a11 * a12 ^ 2 + 3 * a11 * a21 ^ 2 + a11 * a22 ^ 2 + 4 * a11 * k1 ^ 2 + 4 * a11 * k2 ^ 2 + 2 * a12 * a21 * a22)/factorial(5); % n=5
            end
            if n>=6
                total = total + 0.5e1 / 0.64e2 * pi ^ 2 * (5 * a11 ^ 6 + 15 * a11 ^ 4 * a12 ^ 2 + 15 * a11 ^ 4 * a21 ^ 2 + 3 * a11 ^ 4 * a22 ^ 2 + 90 * a11 ^ 4 * k1 ^ 2 + 90 * a11 ^ 4 * k2 ^ 2 + 24 * a11 ^ 3 * a12 * a21 * a22 + 15 * a11 ^ 2 * a12 ^ 4 + 18 * a11 ^ 2 * a12 ^ 2 * a21 ^ 2 + 18 * a11 ^ 2 * a12 ^ 2 * a22 ^ 2 + 180 * a11 ^ 2 * a12 ^ 2 * k1 ^ 2 + 108 * a11 ^ 2 * a12 ^ 2 * k2 ^ 2 + 15 * a11 ^ 2 * a21 ^ 4 + 18 * a11 ^ 2 * a21 ^ 2 * a22 ^ 2 + 108 * a11 ^ 2 * a21 ^ 2 * k1 ^ 2 + 180 * a11 ^ 2 * a21 ^ 2 * k2 ^ 2 + 3 * a11 ^ 2 * a22 ^ 4 + 36 * a11 ^ 2 * a22 ^ 2 * k1 ^ 2 + 36 * a11 ^ 2 * a22 ^ 2 * k2 ^ 2 + 120 * a11 ^ 2 * k1 ^ 4 + 648 * a11 ^ 2 * k1 ^ 2 * k2 ^ 2 + 120 * a11 ^ 2 * k2 ^ 4 + 24 * a11 * a12 ^ 3 * a21 * a22 + 24 * a11 * a12 * a21 ^ 3 * a22 + 24 * a11 * a12 * a21 * a22 ^ 3 + 144 * a11 * a12 * a21 * a22 * k1 ^ 2 + 144 * a11 * a12 * a21 * a22 * k2 ^ 2 + 5 * a12 ^ 6 + 3 * a12 ^ 4 * a21 ^ 2 + 15 * a12 ^ 4 * a22 ^ 2 + 90 * a12 ^ 4 * k1 ^ 2 + 18 * a12 ^ 4 * k2 ^ 2 + 3 * a12 ^ 2 * a21 ^ 4 + 18 * a12 ^ 2 * a21 ^ 2 * a22 ^ 2 + 36 * a12 ^ 2 * a21 ^ 2 * k1 ^ 2 + 36 * a12 ^ 2 * a21 ^ 2 * k2 ^ 2 + 15 * a12 ^ 2 * a22 ^ 4 + 108 * a12 ^ 2 * a22 ^ 2 * k1 ^ 2 + 36 * a12 ^ 2 * a22 ^ 2 * k2 ^ 2 + 120 * a12 ^ 2 * k1 ^ 4 + 216 * a12 ^ 2 * k1 ^ 2 * k2 ^ 2 + 24 * a12 ^ 2 * k2 ^ 4 + 5 * a21 ^ 6 + 15 * a21 ^ 4 * a22 ^ 2 + 18 * a21 ^ 4 * k1 ^ 2 + 90 * a21 ^ 4 * k2 ^ 2 + 15 * a21 ^ 2 * a22 ^ 4 + 36 * a21 ^ 2 * a22 ^ 2 * k1 ^ 2 + 108 * a21 ^ 2 * a22 ^ 2 * k2 ^ 2 + 24 * a21 ^ 2 * k1 ^ 4 + 216 * a21 ^ 2 * k1 ^ 2 * k2 ^ 2 + 120 * a21 ^ 2 * k2 ^ 4 + 5 * a22 ^ 6 + 18 * a22 ^ 4 * k1 ^ 2 + 18 * a22 ^ 4 * k2 ^ 2 + 24 * a22 ^ 2 * k1 ^ 4 + 72 * a22 ^ 2 * k1 ^ 2 * k2 ^ 2 + 24 * a22 ^ 2 * k2 ^ 4 + 16 * k1 ^ 6 + 144 * k1 ^ 4 * k2 ^ 2 + 144 * k1 ^ 2 * k2 ^ 4 + 16 * k2 ^ 6)/factorial(6); % n=6
            end
            if n>=7
                total = total + 0.105e3 / 0.32e2 * k1 * k2 * pi ^ 2 * (5 * a11 ^ 5 + 10 * a11 ^ 3 * a12 ^ 2 + 10 * a11 ^ 3 * a21 ^ 2 + 2 * a11 ^ 3 * a22 ^ 2 + 20 * a11 ^ 3 * k1 ^ 2 + 20 * a11 ^ 3 * k2 ^ 2 + 12 * a11 ^ 2 * a12 * a21 * a22 + 5 * a11 * a12 ^ 4 + 6 * a11 * a12 ^ 2 * a21 ^ 2 + 6 * a11 * a12 ^ 2 * a22 ^ 2 + 20 * a11 * a12 ^ 2 * k1 ^ 2 + 12 * a11 * a12 ^ 2 * k2 ^ 2 + 5 * a11 * a21 ^ 4 + 6 * a11 * a21 ^ 2 * a22 ^ 2 + 12 * a11 * a21 ^ 2 * k1 ^ 2 + 20 * a11 * a21 ^ 2 * k2 ^ 2 + a11 * a22 ^ 4 + 4 * a11 * a22 ^ 2 * k1 ^ 2 + 4 * a11 * a22 ^ 2 * k2 ^ 2 + 8 * a11 * k1 ^ 4 + 24 * a11 * k1 ^ 2 * k2 ^ 2 + 8 * a11 * k2 ^ 4 + 4 * a12 ^ 3 * a21 * a22 + 4 * a12 * a21 ^ 3 * a22 + 4 * a12 * a21 * a22 ^ 3 + 8 * a12 * a21 * a22 * k1 ^ 2 + 8 * a12 * a21 * a22 * k2 ^ 2)/factorial(7); % n=7
            end
            if n>=8
                total = total + 0.35e2 / 0.4096e4 * pi ^ 2 * (35 * a11 ^ 8 + 140 * a11 ^ 6 * a12 ^ 2 + 140 * a11 ^ 6 * a21 ^ 2 + 20 * a11 ^ 6 * a22 ^ 2 + 1120 * a11 ^ 6 * k1 ^ 2 + 1120 * a11 ^ 6 * k2 ^ 2 + 240 * a11 ^ 5 * a12 * a21 * a22 + 210 * a11 ^ 4 * a12 ^ 4 + 300 * a11 ^ 4 * a12 ^ 2 * a21 ^ 2 + 180 * a11 ^ 4 * a12 ^ 2 * a22 ^ 2 + 3360 * a11 ^ 4 * a12 ^ 2 * k1 ^ 2 + 2400 * a11 ^ 4 * a12 ^ 2 * k2 ^ 2 + 210 * a11 ^ 4 * a21 ^ 4 + 180 * a11 ^ 4 * a21 ^ 2 * a22 ^ 2 + 2400 * a11 ^ 4 * a21 ^ 2 * k1 ^ 2 + 3360 * a11 ^ 4 * a21 ^ 2 * k2 ^ 2 + 18 * a11 ^ 4 * a22 ^ 4 + 480 * a11 ^ 4 * a22 ^ 2 * k1 ^ 2 + 480 * a11 ^ 4 * a22 ^ 2 * k2 ^ 2 + 3360 * a11 ^ 4 * k1 ^ 4 + 19200 * a11 ^ 4 * k1 ^ 2 * k2 ^ 2 + 3360 * a11 ^ 4 * k2 ^ 4 + 480 * a11 ^ 3 * a12 ^ 3 * a21 * a22 + 480 * a11 ^ 3 * a12 * a21 ^ 3 * a22 + 288 * a11 ^ 3 * a12 * a21 * a22 ^ 3 + 3840 * a11 ^ 3 * a12 * a21 * a22 * k1 ^ 2 + 3840 * a11 ^ 3 * a12 * a21 * a22 * k2 ^ 2 + 140 * a11 ^ 2 * a12 ^ 6 + 180 * a11 ^ 2 * a12 ^ 4 * a21 ^ 2 + 300 * a11 ^ 2 * a12 ^ 4 * a22 ^ 2 + 3360 * a11 ^ 2 * a12 ^ 4 * k1 ^ 2 + 1440 * a11 ^ 2 * a12 ^ 4 * k2 ^ 2 + 180 * a11 ^ 2 * a12 ^ 2 * a21 ^ 4 + 648 * a11 ^ 2 * a12 ^ 2 * a21 ^ 2 * a22 ^ 2 + 2880 * a11 ^ 2 * a12 ^ 2 * a21 ^ 2 * k1 ^ 2 + 2880 * a11 ^ 2 * a12 ^ 2 * a21 ^ 2 * k2 ^ 2 + 180 * a11 ^ 2 * a12 ^ 2 * a22 ^ 4 + 2880 * a11 ^ 2 * a12 ^ 2 * a22 ^ 2 * k1 ^ 2 + 1728 * a11 ^ 2 * a12 ^ 2 * a22 ^ 2 * k2 ^ 2 + 6720 * a11 ^ 2 * a12 ^ 2 * k1 ^ 4 + 23040 * a11 ^ 2 * a12 ^ 2 * k1 ^ 2 * k2 ^ 2 + 2880 * a11 ^ 2 * a12 ^ 2 * k2 ^ 4 + 140 * a11 ^ 2 * a21 ^ 6 + 300 * a11 ^ 2 * a21 ^ 4 * a22 ^ 2 + 1440 * a11 ^ 2 * a21 ^ 4 * k1 ^ 2 + 3360 * a11 ^ 2 * a21 ^ 4 * k2 ^ 2 + 180 * a11 ^ 2 * a21 ^ 2 * a22 ^ 4 + 1728 * a11 ^ 2 * a21 ^ 2 * a22 ^ 2 * k1 ^ 2 + 2880 * a11 ^ 2 * a21 ^ 2 * a22 ^ 2 * k2 ^ 2 + 2880 * a11 ^ 2 * a21 ^ 2 * k1 ^ 4 + 23040 * a11 ^ 2 * a21 ^ 2 * k1 ^ 2 * k2 ^ 2 + 6720 * a11 ^ 2 * a21 ^ 2 * k2 ^ 4 + 20 * a11 ^ 2 * a22 ^ 6 + 288 * a11 ^ 2 * a22 ^ 4 * k1 ^ 2 + 288 * a11 ^ 2 * a22 ^ 4 * k2 ^ 2 + 960 * a11 ^ 2 * a22 ^ 2 * k1 ^ 4 + 4608 * a11 ^ 2 * a22 ^ 2 * k1 ^ 2 * k2 ^ 2 + 960 * a11 ^ 2 * a22 ^ 2 * k2 ^ 4 + 1792 * a11 ^ 2 * k1 ^ 6 + 23040 * a11 ^ 2 * k1 ^ 4 * k2 ^ 2 + 23040 * a11 ^ 2 * k1 ^ 2 * k2 ^ 4 + 1792 * a11 ^ 2 * k2 ^ 6 + 240 * a11 * a12 ^ 5 * a21 * a22 + 288 * a11 * a12 ^ 3 * a21 ^ 3 * a22 + 480 * a11 * a12 ^ 3 * a21 * a22 ^ 3 + 3840 * a11 * a12 ^ 3 * a21 * a22 * k1 ^ 2 + 2304 * a11 * a12 ^ 3 * a21 * a22 * k2 ^ 2 + 240 * a11 * a12 * a21 ^ 5 * a22 + 480 * a11 * a12 * a21 ^ 3 * a22 ^ 3 + 2304 * a11 * a12 * a21 ^ 3 * a22 * k1 ^ 2 + 3840 * a11 * a12 * a21 ^ 3 * a22 * k2 ^ 2 + 240 * a11 * a12 * a21 * a22 ^ 5 + 2304 * a11 * a12 * a21 * a22 ^ 3 * k1 ^ 2 + 2304 * a11 * a12 * a21 * a22 ^ 3 * k2 ^ 2 + 3840 * a11 * a12 * a21 * a22 * k1 ^ 4 + 18432 * a11 * a12 * a21 * a22 * k1 ^ 2 * k2 ^ 2 + 3840 * a11 * a12 * a21 * a22 * k2 ^ 4 + 35 * a12 ^ 8 + 20 * a12 ^ 6 * a21 ^ 2 + 140 * a12 ^ 6 * a22 ^ 2 + 1120 * a12 ^ 6 * k1 ^ 2 + 160 * a12 ^ 6 * k2 ^ 2 + 18 * a12 ^ 4 * a21 ^ 4 + 180 * a12 ^ 4 * a21 ^ 2 * a22 ^ 2 + 480 * a12 ^ 4 * a21 ^ 2 * k1 ^ 2 + 288 * a12 ^ 4 * a21 ^ 2 * k2 ^ 2 + 210 * a12 ^ 4 * a22 ^ 4 + 2400 * a12 ^ 4 * a22 ^ 2 * k1 ^ 2 + 480 * a12 ^ 4 * a22 ^ 2 * k2 ^ 2 + 3360 * a12 ^ 4 * k1 ^ 4 + 3840 * a12 ^ 4 * k1 ^ 2 * k2 ^ 2 + 288 * a12 ^ 4 * k2 ^ 4 + 20 * a12 ^ 2 * a21 ^ 6 + 180 * a12 ^ 2 * a21 ^ 4 * a22 ^ 2 + 288 * a12 ^ 2 * a21 ^ 4 * k1 ^ 2 + 480 * a12 ^ 2 * a21 ^ 4 * k2 ^ 2 + 300 * a12 ^ 2 * a21 ^ 2 * a22 ^ 4 + 1728 * a12 ^ 2 * a21 ^ 2 * a22 ^ 2 * k1 ^ 2 + 1728 * a12 ^ 2 * a21 ^ 2 * a22 ^ 2 * k2 ^ 2 + 960 * a12 ^ 2 * a21 ^ 2 * k1 ^ 4 + 4608 * a12 ^ 2 * a21 ^ 2 * k1 ^ 2 * k2 ^ 2 + 960 * a12 ^ 2 * a21 ^ 2 * k2 ^ 4 + 140 * a12 ^ 2 * a22 ^ 6 + 1440 * a12 ^ 2 * a22 ^ 4 * k1 ^ 2 + 480 * a12 ^ 2 * a22 ^ 4 * k2 ^ 2 + 2880 * a12 ^ 2 * a22 ^ 2 * k1 ^ 4 + 4608 * a12 ^ 2 * a22 ^ 2 * k1 ^ 2 * k2 ^ 2 + 576 * a22 ^ 2 * a12 ^ 2 * k2 ^ 4 + 1792 * a12 ^ 2 * k1 ^ 6 + 7680 * a12 ^ 2 * k1 ^ 4 * k2 ^ 2 + 4608 * k1 ^ 2 * a12 ^ 2 * k2 ^ 4 + 256 * a12 ^ 2 * k2 ^ 6 + 35 * a21 ^ 8 + 140 * a21 ^ 6 * a22 ^ 2 + 160 * a21 ^ 6 * k1 ^ 2 + 1120 * a21 ^ 6 * k2 ^ 2 + 210 * a21 ^ 4 * a22 ^ 4 + 480 * a21 ^ 4 * a22 ^ 2 * k1 ^ 2 + 2400 * a21 ^ 4 * a22 ^ 2 * k2 ^ 2 + 288 * a21 ^ 4 * k1 ^ 4 + 3840 * a21 ^ 4 * k1 ^ 2 * k2 ^ 2 + 3360 * a21 ^ 4 * k2 ^ 4 + 140 * a21 ^ 2 * a22 ^ 6 + 480 * a21 ^ 2 * a22 ^ 4 * k1 ^ 2 + 1440 * a21 ^ 2 * a22 ^ 4 * k2 ^ 2 + 576 * a21 ^ 2 * a22 ^ 2 * k1 ^ 4 + 4608 * a21 ^ 2 * a22 ^ 2 * k1 ^ 2 * k2 ^ 2 + 2880 * a21 ^ 2 * a22 ^ 2 * k2 ^ 4 + 256 * a21 ^ 2 * k1 ^ 6 + 4608 * a21 ^ 2 * k1 ^ 4 * k2 ^ 2 + 7680 * a21 ^ 2 * k1 ^ 2 * k2 ^ 4 + 1792 * a21 ^ 2 * k2 ^ 6 + 35 * a22 ^ 8 + 160 * a22 ^ 6 * k1 ^ 2 + 160 * a22 ^ 6 * k2 ^ 2 + 288 * a22 ^ 4 * k1 ^ 4 + 768 * a22 ^ 4 * k1 ^ 2 * k2 ^ 2 + 288 * a22 ^ 4 * k2 ^ 4 + 256 * a22 ^ 2 * k1 ^ 6 + 1536 * a22 ^ 2 * k1 ^ 4 * k2 ^ 2 + 1536 * a22 ^ 2 * k1 ^ 2 * k2 ^ 4 + 256 * a22 ^ 2 * k2 ^ 6 + 128 * k1 ^ 8 + 2048 * k1 ^ 6 * k2 ^ 2 + 4608 * k1 ^ 4 * k2 ^ 4 + 2048 * k1 ^ 2 * k2 ^ 6 + 128 * k2 ^ 8) / factorial(8); % n=8
            end
            C = 1/total;
        end
        
        function CinvDiff = normConstApproxDiff(this)
            % Approximates the derivatives of the constant.
            % Currently we support only to 8 summands.
            %
            % Returns:
            %   CinvDiff (1 x 6 vector)
            %       derivatives of normalization constant with respect to kappa1, kappa2, a11, a12, a21, a22       
            %
            % Gerhard Kurz, Uwe D. Hanebeck,
            % Toroidal Information Fusion Based on the Bivariate von Mises Distribution
            % Proceedings of the 2015 IEEE International Conference on Multisensor Fusion and Information Integration (MFI 2015), 
            % San Diego, California, USA, September 2015.            
            
            % derivative of C^(-1)
            a11 = this.A(1,1); a12 = this.A(1,2); a21 = this.A(2,1); a22 = this.A(2,2);
            k1 = this.kappa(1); k2 = this.kappa(2);
            
            % derivative w.r.t. kappa1
            CinvDiff(1)  = 0;
            CinvDiff(1) = CinvDiff(1) + 0; % n=0
            CinvDiff(1) = CinvDiff(1) + 0/factorial(1); % n=1
            CinvDiff(1) = CinvDiff(1) + (0.4e1 * pi ^ 2 * k1)/factorial(2); % n=2
            CinvDiff(1) = CinvDiff(1) + (0.6e1 * k2 * a11 * pi ^ 2)/factorial(3); % n=3
            CinvDiff(1) = CinvDiff(1) + (0.3e1 * pi ^ 2 * k1 * (3 * a11 ^ 2 + 3 * a12 ^ 2 + a21 ^ 2 + a22 ^ 2 + 2 * k1 ^ 2 + 4 * k2 ^ 2))/factorial(4); % n=4
            CinvDiff(1) = CinvDiff(1) + (0.15e2 / 0.4e1 * k2 * pi ^ 2 * (3 * a11 ^ 3 + 3 * a11 * a12 ^ 2 + 3 * a11 * a21 ^ 2 + a22 ^ 2 * a11 + 12 * a11 * k1 ^ 2 + 4 * a11 * k2 ^ 2 + 2 * a12 * a21 * a22))/factorial(5); % n=5
            CinvDiff(1) = CinvDiff(1) + (0.15e2 / 0.16e2 * pi ^ 2 * k1 * (15 * a11 ^ 4 + 30 * a11 ^ 2 * a12 ^ 2 + 18 * a11 ^ 2 * a21 ^ 2 + 6 * a11 ^ 2 * a22 ^ 2 + 40 * a11 ^ 2 * k1 ^ 2 + 108 * a11 ^ 2 * k2 ^ 2 + 24 * a11 * a12 * a21 * a22 + 15 * a12 ^ 4 + 6 * a12 ^ 2 * a21 ^ 2 + 18 * a12 ^ 2 * a22 ^ 2 + 40 * a12 ^ 2 * k1 ^ 2 + 36 * a12 ^ 2 * k2 ^ 2 + 3 * a21 ^ 4 + 6 * a21 ^ 2 * a22 ^ 2 + 8 * a21 ^ 2 * k1 ^ 2 + 36 * a21 ^ 2 * k2 ^ 2 + 3 * a22 ^ 4 + 8 * a22 ^ 2 * k1 ^ 2 + 12 * a22 ^ 2 * k2 ^ 2 + 8 * k1 ^ 4 + 48 * k1 ^ 2 * k2 ^ 2 + 24 * k2 ^ 4))/factorial(6); % n=6
            CinvDiff(1) = CinvDiff(1) + (0.105e3 / 0.32e2 * k2 * pi ^ 2 * (5 * a11 ^ 5 + 10 * a11 ^ 3 * a12 ^ 2 + 10 * a11 ^ 3 * a21 ^ 2 + 2 * a11 ^ 3 * a22 ^ 2 + 60 * a11 ^ 3 * k1 ^ 2 + 20 * a11 ^ 3 * k2 ^ 2 + 12 * a11 ^ 2 * a12 * a21 * a22 + 5 * a11 * a12 ^ 4 + 6 * a11 * a12 ^ 2 * a21 ^ 2 + 6 * a11 * a12 ^ 2 * a22 ^ 2 + 60 * a11 * a12 ^ 2 * k1 ^ 2 + 12 * a11 * a12 ^ 2 * k2 ^ 2 + 5 * a11 * a21 ^ 4 + 6 * a11 * a21 ^ 2 * a22 ^ 2 + 36 * a11 * a21 ^ 2 * k1 ^ 2 + 20 * a11 * a21 ^ 2 * k2 ^ 2 + a11 * a22 ^ 4 + 12 * a11 * a22 ^ 2 * k1 ^ 2 + 4 * a11 * a22 ^ 2 * k2 ^ 2 + 40 * a11 * k1 ^ 4 + 72 * a11 * k1 ^ 2 * k2 ^ 2 + 8 * a11 * k2 ^ 4 + 4 * a12 ^ 3 * a21 * a22 + 4 * a12 * a21 ^ 3 * a22 + 4 * a12 * a21 * a22 ^ 3 + 24 * a12 * a21 * a22 * k1 ^ 2 + 8 * a12 * a21 * a22 * k2 ^ 2))/factorial(7); % n=7
            CinvDiff(1) = CinvDiff(1) + (0.35e2 / 0.64e2 * k1 * pi ^ 2 * (35 * a11 ^ 6 + 105 * a11 ^ 4 * a12 ^ 2 + 75 * a11 ^ 4 * a21 ^ 2 + 15 * a11 ^ 4 * a22 ^ 2 + 210 * a11 ^ 4 * k1 ^ 2 + 600 * a11 ^ 4 * k2 ^ 2 + 120 * a11 ^ 3 * a12 * a21 * a22 + 105 * a11 ^ 2 * a12 ^ 4 + 90 * a11 ^ 2 * a12 ^ 2 * a21 ^ 2 + 90 * a11 ^ 2 * a12 ^ 2 * a22 ^ 2 + 420 * a11 ^ 2 * a12 ^ 2 * k1 ^ 2 + 720 * a11 ^ 2 * a12 ^ 2 * k2 ^ 2 + 45 * a11 ^ 2 * a21 ^ 4 + 54 * a11 ^ 2 * a21 ^ 2 * a22 ^ 2 + 180 * a11 ^ 2 * a21 ^ 2 * k1 ^ 2 + 720 * a11 ^ 2 * a21 ^ 2 * k2 ^ 2 + 9 * a11 ^ 2 * a22 ^ 4 + 60 * a11 ^ 2 * a22 ^ 2 * k1 ^ 2 + 144 * a11 ^ 2 * a22 ^ 2 * k2 ^ 2 + 168 * a11 ^ 2 * k1 ^ 4 + 1440 * a11 ^ 2 * k1 ^ 2 * k2 ^ 2 + 720 * a11 ^ 2 * k2 ^ 4 + 120 * a11 * a12 ^ 3 * a21 * a22 + 72 * a11 * a12 * a21 ^ 3 * a22 + 72 * a11 * a12 * a21 * a22 ^ 3 + 240 * a11 * a12 * a21 * a22 * k1 ^ 2 + 576 * a11 * a12 * a21 * a22 * k2 ^ 2 + 35 * a12 ^ 6 + 15 * a12 ^ 4 * a21 ^ 2 + 75 * a12 ^ 4 * a22 ^ 2 + 210 * a12 ^ 4 * k1 ^ 2 + 120 * a12 ^ 4 * k2 ^ 2 + 9 * a12 ^ 2 * a21 ^ 4 + 54 * a12 ^ 2 * a21 ^ 2 * a22 ^ 2 + 60 * a12 ^ 2 * a21 ^ 2 * k1 ^ 2 + 144 * a12 ^ 2 * a21 ^ 2 * k2 ^ 2 + 45 * a12 ^ 2 * a22 ^ 4 + 180 * a12 ^ 2 * a22 ^ 2 * k1 ^ 2 + 144 * a12 ^ 2 * a22 ^ 2 * k2 ^ 2 + 168 * a12 ^ 2 * k1 ^ 4 + 480 * a12 ^ 2 * k1 ^ 2 * k2 ^ 2 + 144 * a12 ^ 2 * k2 ^ 4 + 5 * a21 ^ 6 + 15 * a21 ^ 4 * a22 ^ 2 + 18 * a21 ^ 4 * k1 ^ 2 + 120 * a21 ^ 4 * k2 ^ 2 + 15 * a21 ^ 2 * a22 ^ 4 + 36 * a21 ^ 2 * a22 ^ 2 * k1 ^ 2 + 144 * a21 ^ 2 * a22 ^ 2 * k2 ^ 2 + 24 * a21 ^ 2 * k1 ^ 4 + 288 * a21 ^ 2 * k1 ^ 2 * k2 ^ 2 + 240 * a21 ^ 2 * k2 ^ 4 + 5 * a22 ^ 6 + 18 * a22 ^ 4 * k1 ^ 2 + 24 * a22 ^ 4 * k2 ^ 2 + 24 * a22 ^ 2 * k1 ^ 4 + 96 * a22 ^ 2 * k1 ^ 2 * k2 ^ 2 + 48 * a22 ^ 2 * k2 ^ 4 + 16 * k1 ^ 6 + 192 * k1 ^ 4 * k2 ^ 2 + 288 * k1 ^ 2 * k2 ^ 4 + 64 * k2 ^ 6))/factorial(8); % n=8
            
            % derivative w.r.t. kappa2
            CinvDiff(2)  = 0;
            CinvDiff(2) = CinvDiff(2) + 0; % n=0
            CinvDiff(2) = CinvDiff(2) + 0/factorial(1); % n=1
            CinvDiff(2) = CinvDiff(2) + (0.4e1 * pi ^ 2 * k2)/factorial(2); % n=2
            CinvDiff(2) = CinvDiff(2) + (0.6e1 * k1 * a11 * pi ^ 2)/factorial(3); % n=3
            CinvDiff(2) = CinvDiff(2) + (0.3e1 * pi ^ 2 * k2 * (3 * a11 ^ 2 + a12 ^ 2 + 3 * a21 ^ 2 + a22 ^ 2 + 4 * k1 ^ 2 + 2 * k2 ^ 2))/factorial(4); % n=4
            CinvDiff(2) = CinvDiff(2) + ( 0.15e2 / 0.4e1 * k1 * pi ^ 2 * (3 * a11 ^ 3 + 3 * a11 * a12 ^ 2 + 3 * a11 * a21 ^ 2 + a11 * a22 ^ 2 + 4 * a11 * k1 ^ 2 + 12 * a11 * k2 ^ 2 + 2 * a12 * a21 * a22))/factorial(5); % n=5
            CinvDiff(2) = CinvDiff(2) + (0.15e2 / 0.16e2 * pi ^ 2 * k2 * (15 * a11 ^ 4 + 18 * a11 ^ 2 * a12 ^ 2 + 30 * a11 ^ 2 * a21 ^ 2 + 6 * a11 ^ 2 * a22 ^ 2 + 108 * a11 ^ 2 * k1 ^ 2 + 40 * a11 ^ 2 * k2 ^ 2 + 24 * a11 * a12 * a21 * a22 + 3 * a12 ^ 4 + 6 * a12 ^ 2 * a21 ^ 2 + 6 * a12 ^ 2 * a22 ^ 2 + 36 * a12 ^ 2 * k1 ^ 2 + 8 * a12 ^ 2 * k2 ^ 2 + 15 * a21 ^ 4 + 18 * a21 ^ 2 * a22 ^ 2 + 36 * a21 ^ 2 * k1 ^ 2 + 40 * a21 ^ 2 * k2 ^ 2 + 3 * a22 ^ 4 + 12 * a22 ^ 2 * k1 ^ 2 + 8 * a22 ^ 2 * k2 ^ 2 + 24 * k1 ^ 4 + 48 * k1 ^ 2 * k2 ^ 2 + 8 * k2 ^ 4))/factorial(6); % n=6
            CinvDiff(2) = CinvDiff(2) + (0.105e3 / 0.32e2 * k1 * pi ^ 2 * (5 * a11 ^ 5 + 10 * a11 ^ 3 * a12 ^ 2 + 10 * a11 ^ 3 * a21 ^ 2 + 2 * a11 ^ 3 * a22 ^ 2 + 20 * a11 ^ 3 * k1 ^ 2 + 60 * a11 ^ 3 * k2 ^ 2 + 12 * a11 ^ 2 * a12 * a21 * a22 + 5 * a11 * a12 ^ 4 + 6 * a11 * a12 ^ 2 * a21 ^ 2 + 6 * a11 * a12 ^ 2 * a22 ^ 2 + 20 * a11 * a12 ^ 2 * k1 ^ 2 + 36 * a11 * a12 ^ 2 * k2 ^ 2 + 5 * a11 * a21 ^ 4 + 6 * a11 * a21 ^ 2 * a22 ^ 2 + 12 * a11 * a21 ^ 2 * k1 ^ 2 + 60 * a11 * a21 ^ 2 * k2 ^ 2 + a11 * a22 ^ 4 + 4 * a11 * a22 ^ 2 * k1 ^ 2 + 12 * a11 * a22 ^ 2 * k2 ^ 2 + 8 * a11 * k1 ^ 4 + 72 * a11 * k1 ^ 2 * k2 ^ 2 + 40 * a11 * k2 ^ 4 + 4 * a12 ^ 3 * a21 * a22 + 4 * a12 * a21 ^ 3 * a22 + 4 * a12 * a21 * a22 ^ 3 + 8 * a12 * a21 * a22 * k1 ^ 2 + 24 * a12 * a21 * a22 * k2 ^ 2))/factorial(7); % n=7
            CinvDiff(2) = CinvDiff(2) + (0.35e2 / 0.64e2 * pi ^ 2 * k2 * (35 * a11 ^ 6 + 75 * a11 ^ 4 * a12 ^ 2 + 105 * a11 ^ 4 * a21 ^ 2 + 15 * a11 ^ 4 * a22 ^ 2 + 600 * a11 ^ 4 * k1 ^ 2 + 210 * a11 ^ 4 * k2 ^ 2 + 120 * a11 ^ 3 * a12 * a21 * a22 + 45 * a11 ^ 2 * a12 ^ 4 + 90 * a11 ^ 2 * a12 ^ 2 * a21 ^ 2 + 54 * a11 ^ 2 * a12 ^ 2 * a22 ^ 2 + 720 * a11 ^ 2 * a12 ^ 2 * k1 ^ 2 + 180 * a11 ^ 2 * a12 ^ 2 * k2 ^ 2 + 105 * a11 ^ 2 * a21 ^ 4 + 90 * a11 ^ 2 * a21 ^ 2 * a22 ^ 2 + 720 * a11 ^ 2 * a21 ^ 2 * k1 ^ 2 + 420 * a11 ^ 2 * a21 ^ 2 * k2 ^ 2 + 9 * a11 ^ 2 * a22 ^ 4 + 144 * a11 ^ 2 * a22 ^ 2 * k1 ^ 2 + 60 * a11 ^ 2 * a22 ^ 2 * k2 ^ 2 + 720 * a11 ^ 2 * k1 ^ 4 + 1440 * a11 ^ 2 * k1 ^ 2 * k2 ^ 2 + 168 * a11 ^ 2 * k2 ^ 4 + 72 * a11 * a12 ^ 3 * a21 * a22 + 120 * a11 * a12 * a21 ^ 3 * a22 + 72 * a11 * a12 * a21 * a22 ^ 3 + 576 * a11 * a12 * a21 * a22 * k1 ^ 2 + 240 * a11 * a12 * a21 * a22 * k2 ^ 2 + 5 * a12 ^ 6 + 9 * a12 ^ 4 * a21 ^ 2 + 15 * a12 ^ 4 * a22 ^ 2 + 120 * a12 ^ 4 * k1 ^ 2 + 18 * a12 ^ 4 * k2 ^ 2 + 15 * a12 ^ 2 * a21 ^ 4 + 54 * a12 ^ 2 * a21 ^ 2 * a22 ^ 2 + 144 * a12 ^ 2 * a21 ^ 2 * k1 ^ 2 + 60 * a12 ^ 2 * a21 ^ 2 * k2 ^ 2 + 15 * a12 ^ 2 * a22 ^ 4 + 144 * a12 ^ 2 * a22 ^ 2 * k1 ^ 2 + 36 * a12 ^ 2 * a22 ^ 2 * k2 ^ 2 + 240 * a12 ^ 2 * k1 ^ 4 + 288 * a12 ^ 2 * k1 ^ 2 * k2 ^ 2 + 24 * a12 ^ 2 * k2 ^ 4 + 35 * a21 ^ 6 + 75 * a21 ^ 4 * a22 ^ 2 + 120 * a21 ^ 4 * k1 ^ 2 + 210 * a21 ^ 4 * k2 ^ 2 + 45 * a21 ^ 2 * a22 ^ 4 + 144 * a21 ^ 2 * a22 ^ 2 * k1 ^ 2 + 180 * a21 ^ 2 * a22 ^ 2 * k2 ^ 2 + 144 * a21 ^ 2 * k1 ^ 4 + 480 * a21 ^ 2 * k1 ^ 2 * k2 ^ 2 + 168 * a21 ^ 2 * k2 ^ 4 + 5 * a22 ^ 6 + 24 * a22 ^ 4 * k1 ^ 2 + 18 * a22 ^ 4 * k2 ^ 2 + 48 * a22 ^ 2 * k1 ^ 4 + 96 * a22 ^ 2 * k1 ^ 2 * k2 ^ 2 + 24 * a22 ^ 2 * k2 ^ 4 + 64 * k1 ^ 6 + 288 * k1 ^ 4 * k2 ^ 2 + 192 * k1 ^ 2 * k2 ^ 4 + 16 * k2 ^ 6))/factorial(8); % n=8
            
            % derivative w.r.t. a11
            CinvDiff(3) = 0;
            CinvDiff(3) = CinvDiff(3) + 0; % n=0
            CinvDiff(3) = CinvDiff(3) + 0/factorial(1); % n=1
            CinvDiff(3) = CinvDiff(3) + (0.2e1 * pi ^ 2 * a11)/factorial(2); % n=2
            CinvDiff(3) = CinvDiff(3) + (0.6e1 * k1 * k2 * pi ^ 2)/factorial(3); % n=3
            CinvDiff(3) = CinvDiff(3) + (0.3e1 / 0.4e1 * pi ^ 2 * (3 * a11 ^ 3 + 3 * a11 * a12 ^ 2 + 3 * a11 * a21 ^ 2 + a11 * a22 ^ 2 + 12 * a11 * k1 ^ 2 + 12 * a11 * k2 ^ 2 + 2 * a12 * a21 * a22))/factorial(4); % n=4
            CinvDiff(3) = CinvDiff(3) + (0.15e2 / 0.4e1 * k1 * k2 * pi ^ 2 * (9 * a11 ^ 2 + 3 * a12 ^ 2 + 3 * a21 ^ 2 + a22 ^ 2 + 4 * k1 ^ 2 + 4 * k2 ^ 2))/factorial(5); % n=5
            CinvDiff(3) = CinvDiff(3) + (0.15e2 / 0.32e2 * pi ^ 2 * (5 * a11 ^ 5 + 10 * a11 ^ 3 * a12 ^ 2 + 10 * a11 ^ 3 * a21 ^ 2 + 2 * a11 ^ 3 * a22 ^ 2 + 60 * a11 ^ 3 * k1 ^ 2 + 60 * a11 ^ 3 * k2 ^ 2 + 12 * a11 ^ 2 * a12 * a21 * a22 + 5 * a11 * a12 ^ 4 + 6 * a11 * a12 ^ 2 * a21 ^ 2 + 6 * a11 * a12 ^ 2 * a22 ^ 2 + 60 * a11 * a12 ^ 2 * k1 ^ 2 + 36 * a11 * a12 ^ 2 * k2 ^ 2 + 5 * a11 * a21 ^ 4 + 6 * a11 * a21 ^ 2 * a22 ^ 2 + 36 * a11 * a21 ^ 2 * k1 ^ 2 + 60 * a11 * a21 ^ 2 * k2 ^ 2 + a11 * a22 ^ 4 + 12 * a11 * a22 ^ 2 * k1 ^ 2 + 12 * a11 * a22 ^ 2 * k2 ^ 2 + 40 * a11 * k1 ^ 4 + 216 * a11 * k1 ^ 2 * k2 ^ 2 + 40 * a11 * k2 ^ 4 + 4 * a12 ^ 3 * a21 * a22 + 4 * a12 * a21 ^ 3 * a22 + 4 * a12 * a21 * a22 ^ 3 + 24 * a12 * a21 * a22 * k1 ^ 2 + 24 * a12 * a21 * a22 * k2 ^ 2))/factorial(6); % n=6
            CinvDiff(3) = CinvDiff(3) + (0.105e3 / 0.32e2 * k1 * k2 * pi ^ 2 * (25 * a11 ^ 4 + 30 * a11 ^ 2 * a12 ^ 2 + 30 * a11 ^ 2 * a21 ^ 2 + 6 * a11 ^ 2 * a22 ^ 2 + 60 * a11 ^ 2 * k1 ^ 2 + 60 * a11 ^ 2 * k2 ^ 2 + 24 * a11 * a12 * a21 * a22 + 5 * a12 ^ 4 + 6 * a12 ^ 2 * a21 ^ 2 + 6 * a12 ^ 2 * a22 ^ 2 + 20 * a12 ^ 2 * k1 ^ 2 + 12 * a12 ^ 2 * k2 ^ 2 + 5 * a21 ^ 4 + 6 * a21 ^ 2 * a22 ^ 2 + 12 * a21 ^ 2 * k1 ^ 2 + 20 * a21 ^ 2 * k2 ^ 2 + a22 ^ 4 + 4 * a22 ^ 2 * k1 ^ 2 + 4 * a22 ^ 2 * k2 ^ 2 + 8 * k1 ^ 4 + 24 * k1 ^ 2 * k2 ^ 2 + 8 * k2 ^ 4))/factorial(7); % n=7
            CinvDiff(3) = CinvDiff(3) + (0.35e2 / 0.512e3 * pi ^ 2 * (35 * a11 ^ 7 + 105 * a11 ^ 5 * a12 ^ 2 + 105 * a11 ^ 5 * a21 ^ 2 + 15 * a11 ^ 5 * a22 ^ 2 + 840 * a11 ^ 5 * k1 ^ 2 + 840 * a11 ^ 5 * k2 ^ 2 + 150 * a11 ^ 4 * a12 * a21 * a22 + 105 * a11 ^ 3 * a12 ^ 4 + 150 * a11 ^ 3 * a12 ^ 2 * a21 ^ 2 + 90 * a11 ^ 3 * a12 ^ 2 * a22 ^ 2 + 1680 * a11 ^ 3 * a12 ^ 2 * k1 ^ 2 + 1200 * a11 ^ 3 * a12 ^ 2 * k2 ^ 2 + 105 * a11 ^ 3 * a21 ^ 4 + 90 * a11 ^ 3 * a21 ^ 2 * a22 ^ 2 + 1200 * a11 ^ 3 * a21 ^ 2 * k1 ^ 2 + 1680 * a11 ^ 3 * a21 ^ 2 * k2 ^ 2 + 9 * a11 ^ 3 * a22 ^ 4 + 240 * a11 ^ 3 * a22 ^ 2 * k1 ^ 2 + 240 * a11 ^ 3 * a22 ^ 2 * k2 ^ 2 + 1680 * a11 ^ 3 * k1 ^ 4 + 9600 * a11 ^ 3 * k1 ^ 2 * k2 ^ 2 + 1680 * a11 ^ 3 * k2 ^ 4 + 180 * a11 ^ 2 * a12 ^ 3 * a21 * a22 + 180 * a11 ^ 2 * a12 * a21 ^ 3 * a22 + 108 * a11 ^ 2 * a12 * a21 * a22 ^ 3 + 1440 * a11 ^ 2 * a12 * a21 * a22 * k1 ^ 2 + 1440 * a11 ^ 2 * a12 * a21 * a22 * k2 ^ 2 + 35 * a11 * a12 ^ 6 + 45 * a11 * a12 ^ 4 * a21 ^ 2 + 75 * a11 * a12 ^ 4 * a22 ^ 2 + 840 * a11 * a12 ^ 4 * k1 ^ 2 + 360 * a11 * a12 ^ 4 * k2 ^ 2 + 45 * a11 * a12 ^ 2 * a21 ^ 4 + 162 * a11 * a12 ^ 2 * a21 ^ 2 * a22 ^ 2 + 720 * a11 * a12 ^ 2 * a21 ^ 2 * k1 ^ 2 + 720 * a11 * a12 ^ 2 * a21 ^ 2 * k2 ^ 2 + 45 * a11 * a12 ^ 2 * a22 ^ 4 + 720 * a11 * a12 ^ 2 * a22 ^ 2 * k1 ^ 2 + 432 * a11 * a12 ^ 2 * a22 ^ 2 * k2 ^ 2 + 1680 * a11 * a12 ^ 2 * k1 ^ 4 + 5760 * a11 * a12 ^ 2 * k1 ^ 2 * k2 ^ 2 + 720 * a11 * a12 ^ 2 * k2 ^ 4 + 35 * a11 * a21 ^ 6 + 75 * a11 * a21 ^ 4 * a22 ^ 2 + 360 * a11 * a21 ^ 4 * k1 ^ 2 + 840 * a11 * a21 ^ 4 * k2 ^ 2 + 45 * a11 * a21 ^ 2 * a22 ^ 4 + 432 * a11 * a21 ^ 2 * a22 ^ 2 * k1 ^ 2 + 720 * a11 * a21 ^ 2 * a22 ^ 2 * k2 ^ 2 + 720 * a11 * a21 ^ 2 * k1 ^ 4 + 5760 * a11 * a21 ^ 2 * k1 ^ 2 * k2 ^ 2 + 1680 * a11 * a21 ^ 2 * k2 ^ 4 + 5 * a11 * a22 ^ 6 + 72 * a11 * a22 ^ 4 * k1 ^ 2 + 72 * a11 * a22 ^ 4 * k2 ^ 2 + 240 * a11 * a22 ^ 2 * k1 ^ 4 + 1152 * a11 * a22 ^ 2 * k1 ^ 2 * k2 ^ 2 + 240 * a11 * a22 ^ 2 * k2 ^ 4 + 448 * a11 * k1 ^ 6 + 5760 * a11 * k1 ^ 4 * k2 ^ 2 + 5760 * a11 * k1 ^ 2 * k2 ^ 4 + 448 * a11 * k2 ^ 6 + 30 * a12 ^ 5 * a21 * a22 + 36 * a12 ^ 3 * a21 ^ 3 * a22 + 60 * a12 ^ 3 * a21 * a22 ^ 3 + 480 * a12 ^ 3 * a21 * a22 * k1 ^ 2 + 288 * a12 ^ 3 * a21 * a22 * k2 ^ 2 + 30 * a12 * a21 ^ 5 * a22 + 60 * a12 * a21 ^ 3 * a22 ^ 3 + 288 * a12 * a21 ^ 3 * a22 * k1 ^ 2 + 480 * a12 * a21 ^ 3 * a22 * k2 ^ 2 + 30 * a12 * a21 * a22 ^ 5 + 288 * a12 * a21 * a22 ^ 3 * k1 ^ 2 + 288 * a12 * a21 * a22 ^ 3 * k2 ^ 2 + 480 * a12 * a21 * a22 * k1 ^ 4 + 2304 * a12 * a21 * a22 * k1 ^ 2 * k2 ^ 2 + 480 * a12 * a21 * a22 * k2 ^ 4))/factorial(8); % n=8
            
            % derivative w.r.t. a12
            CinvDiff(4) = 0;
            CinvDiff(4) = CinvDiff(4) + 0; % n=0
            CinvDiff(4) = CinvDiff(4) + 0/factorial(1); % n=1
            CinvDiff(4) = CinvDiff(4) + (0.2e1 * pi ^ 2 * a12)/factorial(2); % n=2
            CinvDiff(4) = CinvDiff(4) + 0/factorial(3); % n=3
            CinvDiff(4) = CinvDiff(4) + (0.3e1 / 0.4e1 * pi ^ 2 * (3 * a11 ^ 2 * a12 + 2 * a22 * a11 * a21 + 3 * a12 ^ 3 + a12 * a21 ^ 2 + 3 * a22 ^ 2 * a12 + 12 * k1 ^ 2 * a12 + 4 * a12 * k2 ^ 2))/factorial(4); % n=4
            CinvDiff(4) = CinvDiff(4) + (0.15e2 / 0.2e1 * k1 * k2 * pi ^ 2 * (3 * a11 * a12 + a21 * a22))/factorial(5); % n=5
            CinvDiff(4) = CinvDiff(4) + (0.15e2 / 0.32e2 * pi ^ 2 * (5 * a11 ^ 4 * a12 + 4 * a11 ^ 3 * a22 * a21 + 10 * a11 ^ 2 * a12 ^ 3 + 6 * a11 ^ 2 * a12 * a21 ^ 2 + 6 * a11 ^ 2 * a12 * a22 ^ 2 + 60 * a11 ^ 2 * a12 * k1 ^ 2 + 36 * a11 ^ 2 * a12 * k2 ^ 2 + 12 * a11 * a12 ^ 2 * a21 * a22 + 4 * a11 * a21 ^ 3 * a22 + 4 * a11 * a21 * a22 ^ 3 + 24 * a11 * a21 * a22 * k1 ^ 2 + 24 * a11 * a21 * a22 * k2 ^ 2 + 5 * a12 ^ 5 + 2 * a12 ^ 3 * a21 ^ 2 + 10 * a12 ^ 3 * a22 ^ 2 + 60 * a12 ^ 3 * k1 ^ 2 + 12 * a12 ^ 3 * k2 ^ 2 + a12 * a21 ^ 4 + 6 * a12 * a21 ^ 2 * a22 ^ 2 + 12 * a12 * a21 ^ 2 * k1 ^ 2 + 12 * a12 * a21 ^ 2 * k2 ^ 2 + 5 * a12 * a22 ^ 4 + 36 * a12 * a22 ^ 2 * k1 ^ 2 + 12 * a12 * a22 ^ 2 * k2 ^ 2 + 40 * a12 * k1 ^ 4 + 72 * a12 * k1 ^ 2 * k2 ^ 2 + 8 * a12 * k2 ^ 4))/factorial(6); % n=6
            CinvDiff(4) = CinvDiff(4) + (0.105e3 / 0.8e1 * k1 * k2 * pi ^ 2 * (5 * a11 ^ 3 * a12 + 3 * a11 ^ 2 * a21 * a22 + 5 * a11 * a12 ^ 3 + 3 * a11 * a12 * a21 ^ 2 + 3 * a11 * a12 * a22 ^ 2 + 10 * a11 * a12 * k1 ^ 2 + 6 * a11 * a12 * k2 ^ 2 + 3 * a12 ^ 2 * a21 * a22 + a21 ^ 3 * a22 + a21 * a22 ^ 3 + 2 * a21 * a22 * k1 ^ 2 + 2 * a21 * a22 * k2 ^ 2))/factorial(7); % n=7
            CinvDiff(4) = CinvDiff(4) + (0.35e2 / 0.512e3 * pi ^ 2 * (35 * a11 ^ 6 * a12 + 30 * a11 ^ 5 * a22 * a21 + 105 * a11 ^ 4 * a12 ^ 3 + 75 * a11 ^ 4 * a12 * a21 ^ 2 + 45 * a11 ^ 4 * a12 * a22 ^ 2 + 840 * a11 ^ 4 * a12 * k1 ^ 2 + 600 * a11 ^ 4 * a12 * k2 ^ 2 + 180 * a11 ^ 3 * a12 ^ 2 * a21 * a22 + 60 * a11 ^ 3 * a21 ^ 3 * a22 + 36 * a11 ^ 3 * a21 * a22 ^ 3 + 480 * a11 ^ 3 * a21 * a22 * k1 ^ 2 + 480 * a11 ^ 3 * a21 * a22 * k2 ^ 2 + 105 * a11 ^ 2 * a12 ^ 5 + 90 * a11 ^ 2 * a12 ^ 3 * a21 ^ 2 + 150 * a11 ^ 2 * a12 ^ 3 * a22 ^ 2 + 1680 * a11 ^ 2 * a12 ^ 3 * k1 ^ 2 + 720 * a11 ^ 2 * a12 ^ 3 * k2 ^ 2 + 45 * a11 ^ 2 * a12 * a21 ^ 4 + 162 * a11 ^ 2 * a12 * a21 ^ 2 * a22 ^ 2 + 720 * a11 ^ 2 * a12 * a21 ^ 2 * k1 ^ 2 + 720 * a11 ^ 2 * a12 * a21 ^ 2 * k2 ^ 2 + 45 * a11 ^ 2 * a12 * a22 ^ 4 + 720 * a11 ^ 2 * a12 * a22 ^ 2 * k1 ^ 2 + 432 * a11 ^ 2 * a12 * a22 ^ 2 * k2 ^ 2 + 1680 * a11 ^ 2 * a12 * k1 ^ 4 + 5760 * a11 ^ 2 * a12 * k1 ^ 2 * k2 ^ 2 + 720 * a11 ^ 2 * a12 * k2 ^ 4 + 150 * a11 * a12 ^ 4 * a21 * a22 + 108 * a11 * a12 ^ 2 * a21 ^ 3 * a22 + 180 * a11 * a12 ^ 2 * a21 * a22 ^ 3 + 1440 * a11 * a12 ^ 2 * a21 * a22 * k1 ^ 2 + 864 * a11 * a12 ^ 2 * a21 * a22 * k2 ^ 2 + 30 * a11 * a21 ^ 5 * a22 + 60 * a11 * a21 ^ 3 * a22 ^ 3 + 288 * a11 * a21 ^ 3 * a22 * k1 ^ 2 + 480 * a11 * a21 ^ 3 * a22 * k2 ^ 2 + 30 * a11 * a21 * a22 ^ 5 + 288 * a11 * a21 * a22 ^ 3 * k1 ^ 2 + 288 * a11 * a21 * a22 ^ 3 * k2 ^ 2 + 480 * a11 * a21 * a22 * k1 ^ 4 + 2304 * a11 * a21 * a22 * k1 ^ 2 * k2 ^ 2 + 480 * a11 * a21 * a22 * k2 ^ 4 + 35 * a12 ^ 7 + 15 * a12 ^ 5 * a21 ^ 2 + 105 * a12 ^ 5 * a22 ^ 2 + 840 * a12 ^ 5 * k1 ^ 2 + 120 * a12 ^ 5 * k2 ^ 2 + 9 * a12 ^ 3 * a21 ^ 4 + 90 * a12 ^ 3 * a21 ^ 2 * a22 ^ 2 + 240 * a12 ^ 3 * a21 ^ 2 * k1 ^ 2 + 144 * a12 ^ 3 * a21 ^ 2 * k2 ^ 2 + 105 * a12 ^ 3 * a22 ^ 4 + 1200 * a12 ^ 3 * a22 ^ 2 * k1 ^ 2 + 240 * a12 ^ 3 * a22 ^ 2 * k2 ^ 2 + 1680 * a12 ^ 3 * k1 ^ 4 + 1920 * a12 ^ 3 * k1 ^ 2 * k2 ^ 2 + 144 * a12 ^ 3 * k2 ^ 4 + 5 * a12 * a21 ^ 6 + 45 * a12 * a21 ^ 4 * a22 ^ 2 + 72 * a12 * a21 ^ 4 * k1 ^ 2 + 120 * a12 * a21 ^ 4 * k2 ^ 2 + 75 * a12 * a21 ^ 2 * a22 ^ 4 + 432 * a12 * a21 ^ 2 * a22 ^ 2 * k1 ^ 2 + 432 * a12 * a21 ^ 2 * a22 ^ 2 * k2 ^ 2 + 240 * a12 * a21 ^ 2 * k1 ^ 4 + 1152 * a12 * a21 ^ 2 * k1 ^ 2 * k2 ^ 2 + 240 * a12 * a21 ^ 2 * k2 ^ 4 + 35 * a12 * a22 ^ 6 + 360 * a12 * a22 ^ 4 * k1 ^ 2 + 120 * a12 * a22 ^ 4 * k2 ^ 2 + 720 * a12 * a22 ^ 2 * k1 ^ 4 + 1152 * a12 * a22 ^ 2 * k1 ^ 2 * k2 ^ 2 + 144 * a12 * a22 ^ 2 * k2 ^ 4 + 448 * a12 * k1 ^ 6 + 1920 * a12 * k1 ^ 4 * k2 ^ 2 + 1152 * a12 * k1 ^ 2 * k2 ^ 4 + 64 * a12 * k2 ^ 6))/factorial(8); % n=8
            
            % derivative w.r.t. a21
            CinvDiff(5) = 0;
            CinvDiff(5) = CinvDiff(5) + 0; % n=0
            CinvDiff(5) = CinvDiff(5) + 0/factorial(1); % n=1
            CinvDiff(5) = CinvDiff(5) + (0.2e1 * pi ^ 2 * a21)/factorial(2); % n=2
            CinvDiff(5) = CinvDiff(5) + 0/factorial(3); % n=3
            CinvDiff(5) = CinvDiff(5) + (0.3e1 / 0.4e1 * pi ^ 2 * (3 * a11 ^ 2 * a21 + 2 * a22 * a11 * a12 + a12 ^ 2 * a21 + 3 * a21 ^ 3 + 3 * a21 * a22 ^ 2 + 4 * k1 ^ 2 * a21 + 12 * k2 ^ 2 * a21))/factorial(4); % n=4
            CinvDiff(5) = CinvDiff(5) + (0.15e2 / 0.2e1 * k1 * k2 * pi ^ 2 * (3 * a11 * a21 + a12 * a22))/factorial(5); % n=5
            CinvDiff(5) = CinvDiff(5) + (0.15e2 / 0.32e2 * pi ^ 2 * (5 * a11 ^ 4 * a21 + 4 * a11 ^ 3 * a22 * a12 + 6 * a11 ^ 2 * a12 ^ 2 * a21 + 10 * a11 ^ 2 * a21 ^ 3 + 6 * a11 ^ 2 * a21 * a22 ^ 2 + 36 * a11 ^ 2 * a21 * k1 ^ 2 + 60 * a11 ^ 2 * a21 * k2 ^ 2 + 4 * a11 * a12 ^ 3 * a22 + 12 * a11 * a12 * a21 ^ 2 * a22 + 4 * a11 * a12 * a22 ^ 3 + 24 * a11 * a12 * a22 * k1 ^ 2 + 24 * a11 * a12 * a22 * k2 ^ 2 + a12 ^ 4 * a21 + 2 * a12 ^ 2 * a21 ^ 3 + 6 * a12 ^ 2 * a21 * a22 ^ 2 + 12 * a12 ^ 2 * a21 * k1 ^ 2 + 12 * a12 ^ 2 * a21 * k2 ^ 2 + 5 * a21 ^ 5 + 10 * a21 ^ 3 * a22 ^ 2 + 12 * a21 ^ 3 * k1 ^ 2 + 60 * a21 ^ 3 * k2 ^ 2 + 5 * a21 * a22 ^ 4 + 12 * a21 * a22 ^ 2 * k1 ^ 2 + 36 * a21 * a22 ^ 2 * k2 ^ 2 + 8 * a21 * k1 ^ 4 + 72 * a21 * k1 ^ 2 * k2 ^ 2 + 40 * a21 * k2 ^ 4))/factorial(6); % n=6
            CinvDiff(5) = CinvDiff(5) + (0.105e3 / 0.8e1 * k1 * k2 * pi ^ 2 * (5 * a21 * a11 ^ 3 + 3 * a12 * a22 * a11 ^ 2 + 3 * a12 ^ 2 * a21 * a11 + 5 * a21 ^ 3 * a11 + 3 * a21 * a22 ^ 2 * a11 + 6 * a21 * k1 ^ 2 * a11 + 10 * a21 * k2 ^ 2 * a11 + a22 * a12 ^ 3 + 3 * a12 * a21 ^ 2 * a22 + a22 ^ 3 * a12 + 2 * k1 ^ 2 * a22 * a12 + 2 * a12 * a22 * k2 ^ 2))/factorial(7); % n=7
            CinvDiff(5) = CinvDiff(5) + (0.35e2 / 0.512e3 * pi ^ 2 * (35 * a11 ^ 6 * a21 + 30 * a11 ^ 5 * a12 * a22 + 75 * a11 ^ 4 * a12 ^ 2 * a21 + 105 * a11 ^ 4 * a21 ^ 3 + 45 * a11 ^ 4 * a21 * a22 ^ 2 + 600 * a11 ^ 4 * a21 * k1 ^ 2 + 840 * a11 ^ 4 * a21 * k2 ^ 2 + 60 * a11 ^ 3 * a12 ^ 3 * a22 + 180 * a11 ^ 3 * a12 * a21 ^ 2 * a22 + 36 * a11 ^ 3 * a12 * a22 ^ 3 + 480 * a11 ^ 3 * a12 * a22 * k1 ^ 2 + 480 * a11 ^ 3 * a12 * a22 * k2 ^ 2 + 45 * a11 ^ 2 * a12 ^ 4 * a21 + 90 * a11 ^ 2 * a12 ^ 2 * a21 ^ 3 + 162 * a11 ^ 2 * a12 ^ 2 * a21 * a22 ^ 2 + 720 * a11 ^ 2 * a12 ^ 2 * a21 * k1 ^ 2 + 720 * a11 ^ 2 * a12 ^ 2 * a21 * k2 ^ 2 + 105 * a11 ^ 2 * a21 ^ 5 + 150 * a11 ^ 2 * a21 ^ 3 * a22 ^ 2 + 720 * a11 ^ 2 * a21 ^ 3 * k1 ^ 2 + 1680 * a11 ^ 2 * a21 ^ 3 * k2 ^ 2 + 45 * a11 ^ 2 * a21 * a22 ^ 4 + 432 * a11 ^ 2 * a21 * a22 ^ 2 * k1 ^ 2 + 720 * a11 ^ 2 * a21 * a22 ^ 2 * k2 ^ 2 + 720 * a11 ^ 2 * a21 * k1 ^ 4 + 5760 * a11 ^ 2 * a21 * k1 ^ 2 * k2 ^ 2 + 1680 * a11 ^ 2 * a21 * k2 ^ 4 + 30 * a11 * a12 ^ 5 * a22 + 108 * a11 * a12 ^ 3 * a21 ^ 2 * a22 + 60 * a11 * a12 ^ 3 * a22 ^ 3 + 480 * a11 * a12 ^ 3 * a22 * k1 ^ 2 + 288 * a11 * a12 ^ 3 * a22 * k2 ^ 2 + 150 * a11 * a12 * a21 ^ 4 * a22 + 180 * a11 * a12 * a21 ^ 2 * a22 ^ 3 + 864 * a11 * a12 * a21 ^ 2 * a22 * k1 ^ 2 + 1440 * a11 * a12 * a21 ^ 2 * a22 * k2 ^ 2 + 30 * a11 * a12 * a22 ^ 5 + 288 * a11 * a12 * a22 ^ 3 * k1 ^ 2 + 288 * a11 * a12 * a22 ^ 3 * k2 ^ 2 + 480 * a11 * a12 * a22 * k1 ^ 4 + 2304 * a11 * a12 * a22 * k1 ^ 2 * k2 ^ 2 + 480 * a11 * a12 * a22 * k2 ^ 4 + 5 * a12 ^ 6 * a21 + 9 * a12 ^ 4 * a21 ^ 3 + 45 * a12 ^ 4 * a21 * a22 ^ 2 + 120 * a12 ^ 4 * a21 * k1 ^ 2 + 72 * a12 ^ 4 * a21 * k2 ^ 2 + 15 * a12 ^ 2 * a21 ^ 5 + 90 * a12 ^ 2 * a21 ^ 3 * a22 ^ 2 + 144 * a12 ^ 2 * a21 ^ 3 * k1 ^ 2 + 240 * a12 ^ 2 * a21 ^ 3 * k2 ^ 2 + 75 * a12 ^ 2 * a21 * a22 ^ 4 + 432 * a12 ^ 2 * a21 * a22 ^ 2 * k1 ^ 2 + 432 * a12 ^ 2 * a21 * a22 ^ 2 * k2 ^ 2 + 240 * a12 ^ 2 * a21 * k1 ^ 4 + 1152 * a12 ^ 2 * a21 * k1 ^ 2 * k2 ^ 2 + 240 * a12 ^ 2 * a21 * k2 ^ 4 + 35 * a21 ^ 7 + 105 * a21 ^ 5 * a22 ^ 2 + 120 * a21 ^ 5 * k1 ^ 2 + 840 * a21 ^ 5 * k2 ^ 2 + 105 * a21 ^ 3 * a22 ^ 4 + 240 * a21 ^ 3 * a22 ^ 2 * k1 ^ 2 + 1200 * a21 ^ 3 * a22 ^ 2 * k2 ^ 2 + 144 * a21 ^ 3 * k1 ^ 4 + 1920 * a21 ^ 3 * k1 ^ 2 * k2 ^ 2 + 1680 * a21 ^ 3 * k2 ^ 4 + 35 * a21 * a22 ^ 6 + 120 * a21 * a22 ^ 4 * k1 ^ 2 + 360 * a21 * a22 ^ 4 * k2 ^ 2 + 144 * a21 * a22 ^ 2 * k1 ^ 4 + 1152 * a21 * a22 ^ 2 * k1 ^ 2 * k2 ^ 2 + 720 * a21 * a22 ^ 2 * k2 ^ 4 + 64 * a21 * k1 ^ 6 + 1152 * a21 * k1 ^ 4 * k2 ^ 2 + 1920 * a21 * k1 ^ 2 * k2 ^ 4 + 448 * a21 * k2 ^ 6))/factorial(8); % n=8
            
            % derivative w.r.t. a22
            CinvDiff(6) = 0;
            CinvDiff(6) = CinvDiff(6) + 0; % n=0
            CinvDiff(6) = CinvDiff(6) + 0/factorial(1); % n=1
            CinvDiff(6) = CinvDiff(6) + (0.2e1 * pi ^ 2 * a22)/factorial(2); % n=2
            CinvDiff(6) = CinvDiff(6) + 0/factorial(3); % n=3
            CinvDiff(6) = CinvDiff(6) + (0.3e1 / 0.4e1 * pi ^ 2 * (a11 ^ 2 * a22 + 2 * a11 * a12 * a21 + 3 * a22 * a12 ^ 2 + 3 * a21 ^ 2 * a22 + 3 * a22 ^ 3 + 4 * k1 ^ 2 * a22 + 4 * a22 * k2 ^ 2))/factorial(4); % n=4
            CinvDiff(6) = CinvDiff(6) + (0.15e2 / 0.2e1 * pi ^ 2 * k1 * k2 * (a11 * a22 + a12 * a21))/factorial(5); % n=5
            CinvDiff(6) = CinvDiff(6) + (0.15e2 / 0.32e2 * pi ^ 2 * (a11 ^ 4 * a22 + 4 * a11 ^ 3 * a12 * a21 + 6 * a11 ^ 2 * a12 ^ 2 * a22 + 6 * a11 ^ 2 * a21 ^ 2 * a22 + 2 * a11 ^ 2 * a22 ^ 3 + 12 * a11 ^ 2 * a22 * k1 ^ 2 + 12 * a11 ^ 2 * a22 * k2 ^ 2 + 4 * a11 * a12 ^ 3 * a21 + 4 * a11 * a12 * a21 ^ 3 + 12 * a11 * a12 * a21 * a22 ^ 2 + 24 * a11 * a12 * a21 * k1 ^ 2 + 24 * a11 * a12 * a21 * k2 ^ 2 + 5 * a12 ^ 4 * a22 + 6 * a12 ^ 2 * a21 ^ 2 * a22 + 10 * a12 ^ 2 * a22 ^ 3 + 36 * a12 ^ 2 * a22 * k1 ^ 2 + 12 * a12 ^ 2 * a22 * k2 ^ 2 + 5 * a21 ^ 4 * a22 + 10 * a21 ^ 2 * a22 ^ 3 + 12 * a21 ^ 2 * a22 * k1 ^ 2 + 36 * a21 ^ 2 * a22 * k2 ^ 2 + 5 * a22 ^ 5 + 12 * a22 ^ 3 * k1 ^ 2 + 12 * a22 ^ 3 * k2 ^ 2 + 8 * a22 * k1 ^ 4 + 24 * a22 * k1 ^ 2 * k2 ^ 2 + 8 * a22 * k2 ^ 4))/factorial(6); % n=6
            CinvDiff(6) = CinvDiff(6) + (0.105e3 / 0.8e1 * pi ^ 2 * k1 * k2 * (a11 ^ 3 * a22 + 3 * a11 ^ 2 * a12 * a21 + 3 * a11 * a12 ^ 2 * a22 + 3 * a11 * a21 ^ 2 * a22 + a11 * a22 ^ 3 + 2 * a11 * a22 * k1 ^ 2 + 2 * a11 * a22 * k2 ^ 2 + a12 ^ 3 * a21 + a12 * a21 ^ 3 + 3 * a12 * a21 * a22 ^ 2 + 2 * a12 * a21 * k1 ^ 2 + 2 * a12 * a21 * k2 ^ 2))/factorial(7); % n=7
            CinvDiff(6) = CinvDiff(6) + (0.35e2 / 0.512e3 * pi ^ 2 * (5 * a11 ^ 6 * a22 + 30 * a11 ^ 5 * a12 * a21 + 45 * a11 ^ 4 * a12 ^ 2 * a22 + 45 * a11 ^ 4 * a21 ^ 2 * a22 + 9 * a11 ^ 4 * a22 ^ 3 + 120 * a11 ^ 4 * a22 * k1 ^ 2 + 120 * a11 ^ 4 * a22 * k2 ^ 2 + 60 * a11 ^ 3 * a12 ^ 3 * a21 + 60 * a11 ^ 3 * a12 * a21 ^ 3 + 108 * a11 ^ 3 * a12 * a21 * a22 ^ 2 + 480 * a11 ^ 3 * a12 * a21 * k1 ^ 2 + 480 * a11 ^ 3 * a12 * a21 * k2 ^ 2 + 75 * a11 ^ 2 * a12 ^ 4 * a22 + 162 * a11 ^ 2 * a12 ^ 2 * a21 ^ 2 * a22 + 90 * a11 ^ 2 * a12 ^ 2 * a22 ^ 3 + 720 * a11 ^ 2 * a12 ^ 2 * a22 * k1 ^ 2 + 432 * a11 ^ 2 * a12 ^ 2 * a22 * k2 ^ 2 + 75 * a11 ^ 2 * a21 ^ 4 * a22 + 90 * a11 ^ 2 * a21 ^ 2 * a22 ^ 3 + 432 * a11 ^ 2 * a21 ^ 2 * a22 * k1 ^ 2 + 720 * a11 ^ 2 * a21 ^ 2 * a22 * k2 ^ 2 + 15 * a11 ^ 2 * a22 ^ 5 + 144 * a11 ^ 2 * a22 ^ 3 * k1 ^ 2 + 144 * a11 ^ 2 * a22 ^ 3 * k2 ^ 2 + 240 * a11 ^ 2 * a22 * k1 ^ 4 + 1152 * a11 ^ 2 * a22 * k1 ^ 2 * k2 ^ 2 + 240 * a11 ^ 2 * a22 * k2 ^ 4 + 30 * a11 * a12 ^ 5 * a21 + 36 * a11 * a12 ^ 3 * a21 ^ 3 + 180 * a11 * a12 ^ 3 * a21 * a22 ^ 2 + 480 * a11 * a12 ^ 3 * a21 * k1 ^ 2 + 288 * a11 * a12 ^ 3 * a21 * k2 ^ 2 + 30 * a11 * a12 * a21 ^ 5 + 180 * a11 * a12 * a21 ^ 3 * a22 ^ 2 + 288 * a11 * a12 * a21 ^ 3 * k1 ^ 2 + 480 * a11 * a12 * a21 ^ 3 * k2 ^ 2 + 150 * a11 * a12 * a21 * a22 ^ 4 + 864 * a11 * a12 * a21 * a22 ^ 2 * k1 ^ 2 + 864 * a11 * a12 * a21 * a22 ^ 2 * k2 ^ 2 + 480 * a11 * a12 * a21 * k1 ^ 4 + 2304 * a11 * a12 * a21 * k1 ^ 2 * k2 ^ 2 + 480 * a11 * a12 * a21 * k2 ^ 4 + 35 * a12 ^ 6 * a22 + 45 * a12 ^ 4 * a21 ^ 2 * a22 + 105 * a12 ^ 4 * a22 ^ 3 + 600 * a12 ^ 4 * a22 * k1 ^ 2 + 120 * a12 ^ 4 * a22 * k2 ^ 2 + 45 * a12 ^ 2 * a21 ^ 4 * a22 + 150 * a12 ^ 2 * a21 ^ 2 * a22 ^ 3 + 432 * a12 ^ 2 * a21 ^ 2 * a22 * k1 ^ 2 + 432 * a12 ^ 2 * a21 ^ 2 * a22 * k2 ^ 2 + 105 * a12 ^ 2 * a22 ^ 5 + 720 * a12 ^ 2 * a22 ^ 3 * k1 ^ 2 + 240 * a12 ^ 2 * a22 ^ 3 * k2 ^ 2 + 720 * a12 ^ 2 * a22 * k1 ^ 4 + 1152 * a12 ^ 2 * a22 * k1 ^ 2 * k2 ^ 2 + 144 * a12 ^ 2 * a22 * k2 ^ 4 + 35 * a21 ^ 6 * a22 + 105 * a21 ^ 4 * a22 ^ 3 + 120 * a21 ^ 4 * a22 * k1 ^ 2 + 600 * a21 ^ 4 * a22 * k2 ^ 2 + 105 * a21 ^ 2 * a22 ^ 5 + 240 * a21 ^ 2 * a22 ^ 3 * k1 ^ 2 + 720 * a21 ^ 2 * a22 ^ 3 * k2 ^ 2 + 144 * a21 ^ 2 * a22 * k1 ^ 4 + 1152 * a21 ^ 2 * a22 * k1 ^ 2 * k2 ^ 2 + 720 * a21 ^ 2 * a22 * k2 ^ 4 + 35 * a22 ^ 7 + 120 * a22 ^ 5 * k1 ^ 2 + 120 * a22 ^ 5 * k2 ^ 2 + 144 * a22 ^ 3 * k1 ^ 4 + 384 * a22 ^ 3 * k1 ^ 2 * k2 ^ 2 + 144 * a22 ^ 3 * k2 ^ 4 + 64 * a22 * k1 ^ 6 + 384 * a22 * k1 ^ 4 * k2 ^ 2 + 384 * a22 * k1 ^ 2 * k2 ^ 4 + 64 * a22 * k2 ^ 6))/factorial(8); % n=8
        end
                                                   
        function tvm = multiply(this, tvm2)
            % Multiply two bivariate von Mises distribution (exact).
            %
            % Parameters:
            %   tvm2 (ToroidalVMMatrixDistribution)
            %       distribution to multiply with
            % Returns:
            %   tvm (ToroidalVMMatrixDistribution)
            %       renormalized product
            %
            % Gerhard Kurz, Uwe D. Hanebeck,
            % Toroidal Information Fusion Based on the Bivariate von Mises Distribution
            % Proceedings of the 2015 IEEE International Conference on Multisensor Fusion and Information Integration (MFI 2015), 
            % San Diego, California, USA, September 2015.  
            
            assert(isa(tvm2, 'ToroidalVMMatrixDistribution'));

            % mu and kappa (like 1d case)
            C1 = this.kappa(1) * cos(this.mu(1)) + tvm2.kappa(1) * cos(tvm2.mu(1));
            S1 = this.kappa(1) * sin(this.mu(1)) + tvm2.kappa(1) * sin(tvm2.mu(1));
            C2 = this.kappa(2) * cos(this.mu(2)) + tvm2.kappa(2) * cos(tvm2.mu(2));
            S2 = this.kappa(2) * sin(this.mu(2)) + tvm2.kappa(2) * sin(tvm2.mu(2));
            mu_(1) = mod(atan2(S1,C1),2*pi);
            mu_(2) = mod(atan2(S2,C2),2*pi);
            kappa_(1) = sqrt(C1^2+S1^2);
            kappa_(2) = sqrt(C2^2+S2^2);
            
            %A
            M = @(mu) [ cos(mu(1))*cos(mu(2)), -sin(mu(1))*cos(mu(2)), -cos(mu(1))*sin(mu(2)),  sin(mu(1))*sin(mu(2)) ;
                        sin(mu(1))*cos(mu(2)),  cos(mu(1))*cos(mu(2)), -sin(mu(1))*sin(mu(2)), -cos(mu(1))*sin(mu(2)) ;
                        cos(mu(1))*sin(mu(2)), -sin(mu(1))*sin(mu(2)),  cos(mu(1))*cos(mu(2)), -sin(mu(1))*cos(mu(2)) ;
                        sin(mu(1))*sin(mu(2)),  cos(mu(1))*sin(mu(2)),  sin(mu(1))*cos(mu(2)),  cos(mu(1))*cos(mu(2)) ];
            b = M(this.mu) * [this.A(1,1); this.A(2,1); this.A(1,2); this.A(2,2)] +  M(tvm2.mu) * [tvm2.A(1,1); tvm2.A(2,1); tvm2.A(1,2); tvm2.A(2,2)];
            a = M(mu_)\b;
            A_ = [a(1), a(3); 
                  a(2), a(4)];
            
            % create distribution
            tvm = ToroidalVMMatrixDistribution(mu_', kappa_', A_);
        end
        
        function ld = logLikelihoodDiffNumerical(this, samples)
            % Calculates derivatives of loglikelihood using finite
            % differences.
            %
            % Parameters:
            %   samples (2 x n matrix)
            %       one sample per column
            % Returns:
            %       ld (1 x 8 vector)
            %       derivative of loglikelihood with respect to mu1, mu2,
            %       kappa1, kappa2, a11, a12, a21, a22
            
            assert(size(samples,1)==2);
            assert(size(samples,2)>=1);
            
            epsilon = 1E-5;
            
            % derivative w.r.t. mu(1)
            tvmMu1Plus = ToroidalVMMatrixDistribution(this.mu + [epsilon; 0], this.kappa, this.A);
            tvmMu1Minus = ToroidalVMMatrixDistribution(this.mu + [-epsilon; 0], this.kappa, this.A);
            ld(1) = (tvmMu1Plus.logLikelihood(samples) - tvmMu1Minus.logLikelihood(samples))/2/epsilon;
            
            % derivative w.r.t. mu(2)
            tvmMu2Plus = ToroidalVMMatrixDistribution(this.mu + [0; epsilon], this.kappa, this.A);
            tvmMu2Minus = ToroidalVMMatrixDistribution(this.mu + [0; -epsilon], this.kappa, this.A);
            ld(2) = (tvmMu2Plus.logLikelihood(samples) - tvmMu2Minus.logLikelihood(samples))/2/epsilon;
            
            % derivative w.r.t. kappa(1)
            tvmKappa1Plus = ToroidalVMMatrixDistribution(this.mu, this.kappa + [epsilon; 0], this.A);
            tvmKappa1Minus = ToroidalVMMatrixDistribution(this.mu, this.kappa + [-epsilon; 0], this.A);
            ld(3) = (tvmKappa1Plus.logLikelihood(samples) - tvmKappa1Minus.logLikelihood(samples))/2/epsilon;
            
            % derivative w.r.t. kappa(2)
            tvmKappa2Plus = ToroidalVMMatrixDistribution(this.mu, this.kappa + [0; epsilon], this.A);
            tvmKappa2Minus = ToroidalVMMatrixDistribution(this.mu, this.kappa + [0; -epsilon], this.A);
            ld(4) = (tvmKappa2Plus.logLikelihood(samples) - tvmKappa2Minus.logLikelihood(samples))/2/epsilon;
            
            %derivative w.r.t. A(1,1)
            tvmA11Plus = ToroidalVMMatrixDistribution(this.mu, this.kappa, this.A + [epsilon, 0; 0, 0] );
            tvmA11Minus = ToroidalVMMatrixDistribution(this.mu, this.kappa, this.A - [epsilon, 0; 0, 0]);
            ld(5) = (tvmA11Plus.logLikelihood(samples) - tvmA11Minus.logLikelihood(samples))/2/epsilon;
            
            %derivative w.r.t. A(1,2)
            tvmA12Plus = ToroidalVMMatrixDistribution(this.mu, this.kappa, this.A + [0, epsilon; 0, 0] );
            tvmA12Minus = ToroidalVMMatrixDistribution(this.mu, this.kappa, this.A - [0, epsilon; 0, 0]);
            ld(6) = (tvmA12Plus.logLikelihood(samples) - tvmA12Minus.logLikelihood(samples))/2/epsilon;
            
            %derivative w.r.t. A(2,1)
            tvmA21Plus = ToroidalVMMatrixDistribution(this.mu, this.kappa, this.A + [0, 0; epsilon, 0] );
            tvmA21Minus = ToroidalVMMatrixDistribution(this.mu, this.kappa, this.A - [0, 0; epsilon, 0]);
            ld(7) = (tvmA21Plus.logLikelihood(samples) - tvmA21Minus.logLikelihood(samples))/2/epsilon;
            
            %derivative w.r.t. A(2,2)
            tvmA22Plus = ToroidalVMMatrixDistribution(this.mu, this.kappa, this.A + [0, 0; 0, epsilon] );
            tvmA22Minus = ToroidalVMMatrixDistribution(this.mu, this.kappa, this.A - [0, 0; 0, epsilon]);
            ld(8) = (tvmA22Plus.logLikelihood(samples) - tvmA22Minus.logLikelihood(samples))/2/epsilon;
        end
        
        function ld = logLikelihoodDiff(this, samples)
            % Calculates derivatives of loglikelihood using analytical
            % derivatives.
            %
            % Parameters:
            %   samples (2 x n matrix)
            %       one sample per column
            % Returns:
            %       ld (1 x 8 vector)
            %       derivative of loglikelihood with respect to mu1, mu2,
            %       kappa1, kappa2, a11, a12, a21, a22
            %
            % Gerhard Kurz, Uwe D. Hanebeck,
            % Toroidal Information Fusion Based on the Bivariate von Mises Distribution
            % Proceedings of the 2015 IEEE International Conference on Multisensor Fusion and Information Integration (MFI 2015), 
            % San Diego, California, USA, September 2015.  

            assert(size(samples,1)==2);
            assert(size(samples,2)>=1);
            
            CinvDiff = this.normConstApproxDiff();
            n = size(samples,2);
            
            % derivative w.r.t. mu(1)
            ld(1) = sum(this.kappa(1) * sin(samples(1,:) - this.mu(1)) ...
              + sin(samples(1,:) - this. mu(1)) .* this.A(1,1) .* cos(samples(2,:) - this. mu(2)) ...
              + sin(samples(1,:) - this. mu(1)) .* this.A(1,2) .* sin(samples(2,:) - this. mu(2)) ...
              - cos(samples(1,:) - this. mu(1)) .* this.A(2,1) .* cos(samples(2,:) - this. mu(2)) ...
              - cos(samples(1,:) - this. mu(1)) .* this.A(2,2) .* sin(samples(2,:) - this. mu(2)));
          
            % derivative w.r.t. mu(2)
            ld(2) = sum(this.kappa(2) * sin(samples(2,:) - this.mu(2)) ...
              + cos(samples(1,:) - this. mu(1)) .* this.A(1,1) .* sin(samples(2,:) - this. mu(2)) ...
              - cos(samples(1,:) - this. mu(1)) .* this.A(1,2) .* cos(samples(2,:) - this. mu(2)) ...
              + sin(samples(1,:) - this. mu(1)) .* this.A(2,1) .* sin(samples(2,:) - this. mu(2)) ...
              - sin(samples(1,:) - this. mu(1)) .* this.A(2,2) .* cos(samples(2,:) - this. mu(2)));

            % derivative w.r.t. kappa(1)
            ld(3) = -n * this.C * CinvDiff(1) + sum(cos(samples(1,:) - this.mu(1)));
            
            % derivative w.r.t. kappa(2)
            ld(4) = -n * this.C * CinvDiff(2) + sum(cos(samples(2,:) - this.mu(2)));
            
            % derivative w.r.t. A(1,1)
            ld(5) = -n * this.C * CinvDiff(3) + sum(cos(samples(1,:) - this.mu(1)).*cos(samples(2,:) - this.mu(2)));
            
            % derivative w.r.t. A(1,2)
            ld(6) = -n * this.C * CinvDiff(4) + sum(cos(samples(1,:) - this.mu(1)).*sin(samples(2,:) - this.mu(2)));
            
            % derivative w.r.t. A(2,1)
            ld(7) = -n * this.C * CinvDiff(5) + sum(sin(samples(1,:) - this.mu(1)).*cos(samples(2,:) - this.mu(2)));
            
            % derivative w.r.t. A(2,2)
            ld(8) = -n * this.C * CinvDiff(6) + sum(sin(samples(1,:) - this.mu(1)).*sin(samples(2,:) - this.mu(2)));
        end
        
        function l = logLikelihood(this,samples)
            % Calculates loglikelihood.
            %
            % Parameters:
            %   samples (2 x n matrix)
            %       one sample per column
            % Returns:
            %       ld (scalar)
            %       loglikelihood of given samples
            
            assert(size(samples,1)==2);
            assert(size(samples,2)>=1);

            exponent = this.kappa(1) * cos(samples(1,:) - this.mu(1)) ...
              + this.kappa(2) * cos(samples(2,:) - this.mu(2)) ...
              + cos(samples(1,:) - this. mu(1)) .* this.A(1,1) .* cos(samples(2,:) - this. mu(2)) ...
              + cos(samples(1,:) - this. mu(1)) .* this.A(1,2) .* sin(samples(2,:) - this. mu(2)) ...
              + sin(samples(1,:) - this. mu(1)) .* this.A(2,1) .* cos(samples(2,:) - this. mu(2)) ...
              + sin(samples(1,:) - this. mu(1)) .* this.A(2,2) .* sin(samples(2,:) - this. mu(2));
            l = size(samples,2)*log(this.C) + sum(exponent);
        end
        
        function dist = marginalizeTo1D(this, dimension)
            % Get marginal distribution in first or second dimension, i.e., 
            % f(x_1) or f(x_2), respectively.
            %
            % Parameters:
            %   dimension (scalar)
            %       the marginal in which dimension to calculate (1 or 2),
            %       the other dimension is marginalized out
            % Returns:
            %   dist (CustomCircularDistribution)
            %       marginal distribution (marginals are NOT VM distributed in general)
            %
            % Gerhard Kurz, Uwe D. Hanebeck,
            % Toroidal Information Fusion Based on the Bivariate von Mises Distribution
            % Proceedings of the 2015 IEEE International Conference on Multisensor Fusion and Information Integration (MFI 2015), 
            % San Diego, California, USA, September 2015.  
            assert(dimension==1 || dimension==2);
            
            other = 3-dimension;
            alpha = @(x) this.kappa(other) + cos(x - this.mu(dimension)) * this.A(1,1) + sin(x - this.mu(dimension)) * this.A(2,1); 
            beta = @(x) sin(x-this.mu(dimension)) * this.A(2,2) + cos(x-this.mu(dimension)) * this.A(1,2) ;
            f = @(x) 2*pi * this.C * besseli(0,sqrt(alpha(x).^2 + beta(x).^2 )) .* exp(this.kappa(dimension) .* cos(x - this.mu(dimension)));
            dist = CustomCircularDistribution(f);
        end
        
        function tvm = shift(this, shiftAngles)
            % Shift distribution by the given angles
            %
            % Parameters:
            %   shiftAngles (dim x 1 column vector) 
            %       angles to shift by
            % Returns:
            %   hd (ToroidalVMMatrixDistribution)
            %       shifted distribution
            assert(all(size(shiftAngles) == [this.dim, 1]));
            
            tvm = this;
            tvm.mu = mod(this.mu+shiftAngles,2*pi);
        end
    end
    
    methods (Static)
        function tvm = mleNumerical(samples, method)
            % Obtain distribution from samples using MLE (based on
            % numerical optimization).
            %
            % Parameters:
            %   samples (2 x n matrix)
            %       one sample per column
            %   method (string)
            %       optimization method to use
            % Returns:
            %   tvm (TorusVMMatrixDistribution)
            %       distribution whose parameters maximize the likelihood
            
            assert(size(samples,1) == 2);
            assert(size(samples,2) >= 1);
            
            % goal function without derivative
            function y = f(x)
                muTemp = [x(1); x(2)];
                kappaTemp = [x(3); x(4)];
                Atemp = [x(5) x(6); x(7) x(8)];
                if all(kappaTemp>=0)
                    dist = ToroidalVMMatrixDistribution(muTemp, kappaTemp, Atemp);
                    y = -dist.logLikelihood(samples);
                else
                    y = Inf; % implicit constraint
                end
            end
            
            % goal function with derivative
            function [y, grad] = fgrad(x)
                muTemp = [x(1); x(2)];
                kappaTemp = [x(3); x(4)];
                Atemp = [x(5) x(6); x(7) x(8)];
                if all(kappaTemp>=0)
                    dist = ToroidalVMMatrixDistribution(muTemp, kappaTemp, Atemp);
                    y = -dist.logLikelihood(samples);
                    grad = -dist.logLikelihoodDiff(samples);
                else
                    % implicit constraint
                    y = Inf;
                    grad = Inf*ones(1,6);
                end
            end
            
            if nargin < 2
                method = 'default';
            end
            
            % start value
            twd = ToroidalWDDistribution(samples);
            mu_ = twd.circularMean();
            marg1 = twd.marginalizeTo1D(1);
            marg2 = twd.marginalizeTo1D(2);
            vm1 = VMDistribution.fromMoment(marg1.trigonometricMoment(1));
            vm2 =  VMDistribution.fromMoment(marg2.trigonometricMoment(1));
            kappa_(1) = vm1.kappa;
            kappa_(2) = vm2.kappa;
            A_ = zeros(2,2);
            startValue = [mu_(1), mu_(2), kappa_(1), kappa_(2), A_(1,1), A_(1,2), A_(2, 1), A_(2,2)];
            
            % perform optimization
            if strcmp(method, 'default') || strcmp(method, 'nelder-mead')
                % derivative-free method, slow but fairly robust
                x = fminsearch(@f,startValue,optimset('display','off'));
            elseif strcmp(method, 'quasi-newton')
                % approximates derivative
                x = fminunc(@f,startValue,optimoptions('fminunc','display','off','Algorithm','quasi-newton'));
            elseif strcmp(method, 'trust-region')
                % uses exact derivative
                x = fminunc(@(x) fgrad(x),startValue,optimoptions('fminunc','display','off','GradObj','on','Algorithm','trust-region'));
            elseif strcmp(method, 'trust-region-reflective')
                % uses exact derivative, explicit contraints for kappa>0
                x = fmincon(@(x) fgrad(x),startValue,[],[],[],[],[-Inf -Inf 0 0 -Inf -Inf -Inf -Inf],Inf*ones(1,8), [], optimset('display','off','GradObj','on','algorithm','trust-region-reflective'));
            elseif strcmp(method, 'interior-point')
                % uses exact derivative, explicit contraints for kappa>0
                x = fmincon(@(x) fgrad(x),startValue,[],[],[],[],[-Inf -Inf 0 0 -Inf -Inf -Inf -Inf],Inf*ones(1,8), [], optimset('display','off','GradObj','on','algorithm','interior-point'));
            else
                error('unsupported method')
            end
            
            mu_ = [x(1); x(2)];
            kappa_ = [x(3); x(4)];
            A_ = [x(5) x(6); x(7) x(8)];
            tvm = ToroidalVMMatrixDistribution(mu_, kappa_, A_);
        end        
                
    end
    
end

